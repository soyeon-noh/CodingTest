# 연산량과 시간복잡도

### 코드와 실행시간

- 우리가 작성하는 코드는 CPU가 일일이 명령어 형태로 실행
- 당연히 처리할 명령어가 많을수록 처리 사간이 오래 걸림
- 보통 천만 ~ 수 억 번 연산을 하면 1 ~~2초가 소요됨
  - 자신의 알고리즘을 대략적으로 평가할 수 있음
  - 감각과 경험이 필요
- 입력과 출력 연산은 조금 더 느림

### 반복문의 연산량

- 반복문은 코드의 길이를 짧게 줄여 줌
- 실제 연산 횟수가 줄어드는 것이 아님
- 코드가 짧다고 명령어가 적은 것은 아니기 때문

### 연산량 예측하기

- 우리가 작성한 코드가 어느 정도의 연산량을 가지는지 예측할 수 있어야 함
- 정해진 제한시간 내 실행할 수 있는지 대략적인 검증이 가능하기 때문

### 시간 복잡도 (Time Complexity)

- 시간 복잡도란, 입력에 따라 변하는 데이터의 크기에 대해 함수 형태로 알고리즘이 수행되는 시간(연산량)을 표현하는 방법
- `입력데이터`
- O(mkl)
- 데이터의 수(혹은 크기)가 늘어나면 연산량이 얼마나 가파르게 늘어날지에 대한 지표
- 기본적으로 일어날 수 있는 최대(최악)의 연산량을 표시
- 즉, 정확한 연산량을 구하는 것이 목적은 아님
- "최악의 경우 이 정도 수준까지 연산이 일어날 수 있다" 정도의 의미
  - 연산량을 함수 형태로 표현하되, 낮은 계수와 상수는 생략한다
  - 낮은 차수와 랭크의 함수는 생량한다.
    - 랭크는 미분값이라고 보면된다. 미분값이 큰걸 사용.
- 최대값 O(n), 선택정렬 O(n^2)

### 시간 복잡도의 계산

- 데이터의 크기와 무관하게 일어나는 연산은 모두 O(1)이다.
- 데이터의 크기가 커질수록 미미한 연산량이기 때문

- ex) printf("Hello World!\n");
- ex) for(int i=0; i<10; i++)

- 최고 차 혹은 최고 랭크의 항만 기억하며 그 외 상수와 계수는 무시한다.

- 간단한 연산을 기준으로 그 연산이 몇 번 실행될 지 고려하면 됨
- 그리고 그 시간 복잡도를 곱하자.
- ex) n \* O(n) = O(n^2)

### 시간 복잡도를 최악의 경우에 대하여 계산하는 이유

- 최악의 경우에 대한 연산량이 제한 시간내에 처리 가능한 정도라면, 항상 시간 제한을 만족할 것이기 때문

### 같은 시간 복잡도의 알고리즘도 실제 연산량은 많이 다를 수 있음

- 계소 및 상수 항의 생략
- 낮은 차수 및 랭크 생략
- 최악의 경우의 빈도수
- 데이터 크기에 따른 대소 관계 역전
  - n에 따라 O(n^2)이 O(n)보다 적을 수 있음

### 실제 연산량 줄이기 - 가지치기

- 정답과 관련이 없는 반복이나 함수를 생략하면 실제 연산량을 많이 개선할 수 있다.
- Q) 학생들이 키 순으로 서 있다. 생일이 12월인 학생 중 가장 키가 큰 학생을 찾는 방법은?

- 문제에서 주어진 조건을 이용하여 가지치가가 가능한 경우가 많음
  - 정렬, 중복, 범위와 크기, 기타 규칙 등의 특수한 입력 조건
- 경우에 따라서 가지치기로 인해 시간 복잡도도 줄어들 수 있다.
- 계산 과정에서 답이 될 수 없음을 발견한 경우 강제로 종료함.

### 실제 연산량 줄이기 - 반복문 생략

- 문제에서 주어진 조건으로 인해 다중 반복문을 하나 이하의 반복문으로 줄이는 경우가 있음.
