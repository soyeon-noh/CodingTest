# 배열과 테크닉

## 배열

- 배열은 하나의 이름과 번호로 여러 저장공간을 접근할 수 있는 구조이다.

### 배열의 장점

- 각 원소는 0부터 번호로 접근할 수 있으며 접근 및 수정에 걸리는 시간복잡도는 O(1)이다. (빠르다)

### 배열의 단점

- 인덱스는 항상 0부터 연속적으로 부여됨
- 기본적으로 고정적인 길이를 갖도록 미리 선언 (메모리 낭비 요인)
  - ArrayList, vector, list 등으로 어느 정도 개선 가능
- 배열 중간에 원소를 추가, 삭제, 크기변경은 O(N)의 의 시간복잡도를 갖는다. N은 배열의 전체 길이임.
- 선언과 초기화도 길이 N에 비례한 시간이 걸림.
- 선언한 길이만큼 메모리를 차지함.
- C++의 경우 지역 배열을 크게 잡으면 StackOverflow 발생

- **이후에 배울 자료구조 방법은 이러한 배열의 단점을 개선하기 위해 등장**

## 공간과 시간

- 배열이나 변수와 같은 공간에 필요한 값을 저장해두거나 **미리 계산**해 두면 다양한 방법으로 연산량을 줄이는 것이 가능함.
- 하지만 배열은 공간을 많이 차지하므로 사용할 수 있는 크기가 제한적이다.
- **메모리 제한 이내**에서 최대한 연산량을 줄일 수 있는 방향으로 배열과 자료구조를 활용해야 한다.

## 다양한 테크닉

### 전처리 (Preprocessing)

- 필요한 값들을 미리 모두 구해 두거나, 데이터를 미리 전부 가공해두는 기법
- 문제에서 사용될 방식에 따라 값들을 계산, _정렬_, 가공하는 것

### 메모제이션(Memoization)

- 중복 계산이 많이 일어날 것 같은 값들을 한 번 계산한 이후에 배열과 같은 *공간에 저장*해두고, 추가적인 계산이 필요할 때 다시 계산하지 않고 저장된 값을 재활용하는 기법

### 인덱싱 (Indexing)

- 불규칙적인 데이터에 특정 기준으로 번호를 매기는 작업
- 이렇게 붙여진 번호로 배열의 각 공간을 활용할 수 있음.

### 공간에 의미 부여하기

- 배열의 각 칸을 단순히 '몇 번재 칸'이 아니라, 해당 칸의 인덱스를 기준으로 다양한 의미를 붙여서 활용할 수 있어야 한다.
- 처리방법에 따라 각 칸의 의미는 계속 변함.

```c++
int data[10000];
for(int i = 0; i < n; i++)
    scanf("%d", &data[i]);
// data[i] := i번째로 입력받은 데이터

sort(data, data);
// data[i] := 전체 값 중 i번째로 작은 값

```
