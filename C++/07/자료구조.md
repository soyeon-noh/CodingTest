# 자료구조

## 자료구조의 정의

- 컴퓨터에서 처리할 자료를 효율적으로 관맇고 구조화시키기 위한 학문
- 즉, 자료를 효율적으로 사용하기 위해 자료의 특성에 따라 분류하여 구성하고 저장 및 처리하는 모든 작업을 의미
  - 자료 구조는 자료의 표현과 그것에 관련된 연산
  - 자료 구조는 일련의 자료들을 조직하고 구조화하는 것
  - 자료 구조에 따라 프로그램 실행 시간이 달라짐

## 자료구조의 분류

- 자료구조
  - 단순구조 (정수, 실수, 문자, 문자열) \*
  - 선형구조
    - 리스트
    - 연결리스트 (단순 연결 리스트, 이중 연결 리스트, 원형 연결 리스트)
    - 스택 \*
    - 큐 \*
    - 덱 \*
  - 비선형구조
    - 트리 (일반트리, 이진트리) \*
    - 그래프 (방향그래프, 무방향그래프) \*
  - 파일구조
    - 순차파일
    - 색인파일
    - 직접파일

## 자료구조의 이용

- 정렬(Sort) : 기억장치 내의 자료를 일정한 순서에 따라 나열하는 것
- 검색(Search) : 기억장치 내의 자료를 찾는 것
- 파일 편성 : 자료를 기억 매체에 저장할 때의 파일 구조
- 인덱스 : 파일에서 특정 자료를 빠르게 찾기 위한 색인표
- 데이터의 특징과 사용 용도에 알맞은 자료구조를 선택해야 함.
- 언어별로 바로 사용할 수 있는 형태로 제공
  - 배열, 리스트, 맵, 세트, 스택 큐 등

## 리스트

### 선형 리스트(Linear List) : 배열

- 배열과 같이 연속되는 기억 장소에 저장되는 리스트
- 다음과 같은 특징을 가짐
  - 가장 간단한 자료구조
  - 접근 속도가 빠름
  - 기억 장소를 연속으로 배정받기 때문에 기억 공간 효율이 가장 좋음
  - 삽입, 삭제 시 자료의 이동이 필요하기 때문에 작업이 번거롭고 오래걸림.

### 연결 리스트(Linked List)

- 자료들을 반드시 연속적으로 배열시키지는 않고, 임의의 기억 공간에 기억시키되, 자료 항목의 순서에 따라 노드의 포인터 부분을 이용하여 서로 연결시킴.
- 특징
  - 노드의 삽입, 삭제 작업 용이
  - 연결을 위한 링크 부분이 필요하기 때문에 선형 리스트에 비해 기억 공간 효유링 좋지 않음
  - 포인터 찾는 시간이 필요하기 때문에 접근 속도 느림
    - a[2]를 구하고자할때 바로 못가고 a[0]을 찾고 계속 따라가서 찾아야함
  - 트리를 표현할 때 가장 적합한 구조
  - 삽입, 삭제 시 자료의 이동이 필요하기 때문에 작업이 번거로움.
  - 종류: 단순 연결 리스트, 이중 연결 리스트 등...

## 스택

### 스택의 개념

- 리스트의 한 쪽 끝(Top)으로만 자료의 삽입과 삭제가 이루어짐
- 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출(LIFO : Last In First Out)
- 내부 구현은 보통 Linked List로 되어 있음.

### 스택의 사용 사례

- 재귀 알고리즘
  - 재귀적으로 함수를 호출해야 하는 경우 임시 데이터를 스택에 넣음
  - 재귀 함수를 빠져나와 검색을 할 때는 스택에 넣어 두었던 임시 데이터를 빼 준다.
  - 스택은 재귀 알고리즘을 반복적 형태를 통해서 구현할 수 있게 함.
- 웹 브라우저 방문 기록(뒤로 가기), 실행 취소(Undo)
  - 인터럽트 발생 시 복귀 주소를 저장
- 역순 문자열 만들기
- 수식의 괄호 검사 (실습)
  - 올바른 괄호 문자열(VPS) 판단하기
- 후위표기법
  - 연산자를 피연산자의 뒤에 놓는 방법

### 스택의 사용 방법 (코드)

- 헤더파일 추가
  ```c++
  #include <stack>
  ```
- 표준 네임스페이스 사용하면 편리
  ```c++
  using namespace std;
  ```
- 스택 변수 선언

  ```c++
  stack<datatype> 변수명;
  stack<char> st;
  ```

- bool empty() const;
  - 비어있는지 확인;
  - ex) st.empty();
- size_type size() const;
  - 사이즈 반환
  - ex) st.size();
- value_type& top();
- const value_type& top() const;
  - 맨위에 있는 인자 반환
  - ex) st.top();
- void push(const value_type& val);
  - 데이터(value) 삽입
  - ex) st.push(999);
- void pop();
  - top 이 가리키는 원소를 삭제합니다.
  - ex) st.pop();

### 스택의 사용 사례 (코드)

```c++
#include<iostream>
#include<stack>
using namespace std;

int main(void){
    stack<int> st;

    st.push(10);
    st.push(20);
    st.push(30);
    st.push(40);
    st.push(50);

    cout << "st.size() : " << st.size() << endl;
    cout << "st.top() -> st.pop() " << endl;
    while(!st.empty()){
        cout << st.top() << endl;
        st.pop();
    }
    return 0;
}
```

### 스택 vs. 벡터

- 스택 : 데크 컨테이너 - 내부 구조가 리스트
- 벡터 : 벡터 컨테이너 - 내부 구조가 동적 배열
- 평균적으로 데크가 벡터보다 더 빠르게 동작 (그러나 데이터양이 매우 크지 않은 이상 차이 경미)
- 스택은 LIFO만 가능
- 벡터는 맨 앞 데이터 삽입(push_front)/삭제(pop_front) 및 중간 데이터 삽입(insert)/삭제(erase)도 가능
- LIFO 로만 변수를 사용할 경우, 스택으로 선언하는 것이 코드의 가독성에 유리함.
- 벡터로 선언할 경우, 배열로도 사용할 수 있기 때문에 목적이 스택이라 해도 바로 알기 어려움.
- 용도에 따라 적절한 컨테이너 사용이 필요
